# Първо теоретично контролно по ФП
### 06.04.24
<br>

---
## Резултат -> 4,75
---

### Въпрос 1
Опишете общия вид на дефиниция на функция с условия (guards) в езика Haskell и процеса на оценяване на обръщение към такава функция.

Отговор:  
```hs
function_name x1 x2 ... xK

    | guard1 = expression1

    | guard2 = expression2

...

    | guardN-1 = expressionN-1

  ( | otherwise = expressionN )
```

Изразите `guardI` връщат резултат от тип `Bool`


При извикване на функцията `function_name` и правилно подаване на нейните параметри `x1`, ... ,`xK` всяко едно от условията (guards) ще бъде оценено в реда на дефиниране.

Ако попаднем в някое от тях, т.е. оценката е `True`, ще бъде изпълнен изразът, който му е съпоставен.

Дефинирането на условие `otherwise` **не** е *задължително*. Неговият израз ще бъде изпълнен само когато всяко друго от условията върне `False`. Ако няма дефиниран `otherwise` и всички условия върнат `False`, функцията ще върне грешка по време на изпълнение.

<br>

### Въпрос 2
Кои от следните конструкции са коректно дефинирани (валидни) списъци в Haskell? Посочете типовете на валидните списъци, а за останалите обяснете защо не са валидни.  
(а) `[’X’,”X”]`  
(б) `[[[1,2,3,4,5]],[]]`  
(в) `[(2024,”Hi”),(2024,”Hi”,”Everybody”)]`  
(г) `[[”2024”,”Hi”],[”2024”,”Hi”,”Everybody”]]`  

Отговор:  
(a) **невалиден**: `'X' :: Char`, докато `"X"` е низ от символи, т.е. `[Char]` или `String` (`"X" :: String`)  
(б) **валиден**: `[[[1,2,3,4,5]],[]] :: [[Int]]`  
(в) **невалиден**: `(2024,”Hi”) :: (Int, String)`, докато `(2024,”Hi”,”Everybody”) :: (Int, String, String)`, т.е. двата кортежа са от различен тип, понеже имат различен брой елементи  
(г) **валиден**: `[[”2024”,”Hi”],[”2024”,”Hi”,”Everybody”]] :: [[String]]`  

<br>

### Въпрос 3
Каква е областта на действие на променливите в езика Haskell? Дайте поне два примера, илюстриращи дефиниции на променливи с различни области на действие.

Отговор:  
В Haskell можем да дефинираме константни (immutable) променливи в глобалния контекст на програмата, в областта само на конкретна функция или само за единичен израз 


<ins>Област на действие за глобалния контекст:</ins>  
Всички дефиниции на най-високо ниво в Haskell имат за своя област на действие целия скрипт, в който са включени и могат да бъдат използвани във всички дефиниции, включени в скрипта.

<ins>Област на действие за конкретна функция:</ins>  
Използваме `where` 
```hs
f p1 p2 … pk 
 | guard1 = expression1
 . . .
 | otherwise = expressionN
 where v1 a1 … an = r1 v2 = r2
```
Всеики от изразите, дефинирани в `where` може да бъде извикван неопределен брой пъти, но ще се оцени само веднъж

<ins>Област на действие за конкретен израз:</ins>  
Използваме `let <name>= expression in ...`
Н.п.: 
```hs
foo :: Int
foo x
   | x > 0 = let square = x ^ x in x - square
   | x <= 0 = let square = x ^ x in x + square
```
Тук `square` ще бъде оценен в рамките на всеки израз, в който бива извикван

<br>

### Въпрос 4
Дайте пример за дефиниция на функция, в която се използва обща (а не примитивна) рекурсия върху списъци. Обяснете каква задача се решава с помощта на тази функция.

Отговор:  
Такъв пример е имплементация на алгоритъма `quickSort`
```hs
quickSort :: (Ord a) => [a] -> [a]
quickSort [] = []
quickSort (x:xs) = quickSort [y | y <- xs, y <= x]
                   ++ [x] ++
                   quickSort [y | y <- xs, y > x]
```
Така `quickSort` рекурсивно разделя списъка на по-малки подсписъци, които са по-лесни за сортиране, и след това комбинира сортираните подсписъци, за да получи целия сортиран списък. Този подход е пример за *обща рекурсия*, тъй като функцията извиква сама себе си с различни (по-малки) части от изходния проблем, докато не достигне базовия случай.

<br>

### Въпрос 5
Обяснете понятието „рекурсивен изчислителен процес“. Дефинирайте функция на езика Haskell, която генерира рекурсивен изчислителен процес, и обяснете предназначението на тази функция.

Отговор:  
Рекурсивен изчислителен процес се отнася до метода на изчисление, при който функция извиква сама себе си с нови аргументи като част от своето изпълнение. Всяко такова извикване се нарича рекурсивен случай и води до поредица от извиквания до достигане на базов случай, при който рекурсията спира. Рекурсивните изчислителни процеси са мощен инструмент за решаване на задачи, които могат да бъдат разделени на по-малки подзадачи.

<br>

### Въпрос 6
Нека е даден списък lst от тип `[([Char],Int,Float)]`, съдържащ данни за имената, факултетните номeра и успеха на студентите от една група. Напишете изрази на Haskell, с помощта на които се получават:  

(а) списък от факултетните номера на студентите от групата  
(б) броят на студентите в групата, които имат много добър успех  

Отговор:
```hs
lst :: [([Char],Int,Float)]
```

<br>

### Въпрос 7
Как се конструира списък чрез определяне на неговия обхват (list comprehension) в езика Haskell? Обяснете общия случай и дайте поне два примера, в които се използват различни възможности на тази техника (включително напишете получените резултати).

Отговор:  
List comprehension позволява лесно създаване на списъци чрез изразяване на тяхната структура и филтриране на елементите, които трябва да бъдат включени. Общият вид на тази конструкция е следният:  

`[x| x <- генератор, предикат]`
- **expr** е израз, който определя стойността на всеки елемент в новия списък.
- **генератор** е израз, който генерира последователност от стойности, обикновено във формата `x <- [a .. b]`, където x последователно преминава през всички стойности в списъка.
- **предикат** (по избор) е условие, което филтрира стойностите, генерирани от генератора. Елементите, за които предикатът връща True, се включват в крайния списък.

```hs
primes = [p | p <- [2..], isPrime] -- безкраен списък от всички прости числа

evenSquares = [x^2 | x <- [1 .. 10, even x] -- списък от квадратите на четните числа от 1 до 10
```

<br>

### Въпрос 8
Обяснете понятието „образец“ (pattern) в Haskell. Посочете поне три типа образци и формулирайте правилата за успешното им съпоставяне със съответните аргументи.

Отговор:  
Образецът е езикова конструкция, чрез която се описва в обобщен вид отделен възможен случай за даден аргумент. Ако някой от образците съвпада с подадените на функцията аргументи, функцията се оценява според дефиницията на този образец  

За образец може да се използват:
- *литерали* -> проверява дали даден аргумент съвпада със стойността на литерала
- *име на променлива* (н.п. `var_name`) -> съпоставя аргументa с произволна стойност, отговаряща на типа му, ако е дефиниран такъв
- *безусловно съпоставяне (wildcard)* `_` -> съпоставя произволен аргумент
- *Вектор - образец* `(p1,p2, … ,pn)` -> за да бъде съпоставим с него, аргументът трябва да има вида `(v1,v2, … ,vn)`, като всяко vi трябва да бъде съпоставимо със съответното `pi`;
- *List - образец* -> позволява ни да дадем точен

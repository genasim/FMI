# Второ теоретично контролно по ФП

### 02.06.24

<br>

---

## Резултат ->

---

### Въпрос 1

Обяснете същността на „мързеливото“ оценяване (lazy evaluation) в езика Haskell. Дайте поне два примера, които илюстрират различни аспекти на „мързеливото“ оценяване (включително проследете стъпка по стъпка съответните процеси на оценяване).

Отговор:
Мързеливото оценяване (lazy evaluation) е стратегия за оценяване, при която изразите не се изчисляват веднага, когато са дефинирани, а само когато техните стойности са необходими за извършване на дадена операция. Това позволява по-ефективно използване на паметта и по-добра производителност в някои случаи, като същевременно позволява работа с безкрайни структури от данни.

Примери:  
1. Безкраен списък

Ще дефинираме безкраен списък от всички положителни цели числа и ще извлечем първите пет елемента от него.

```hs
numbers :: [Int]
numbers = [1..]

firstFive :: [Int]
firstFive = take 5 numbers
```

Оценяване:  
    1. `numbers = [1..]` - дефиниця  
    2. `firstFive = take 5 numbers` - извиква take със съответните аргументи  
    3. `take 5 numbers` - изпълнява се take като се взимат първите 5 елемента и се агрегират в нов списък

<br>

### Въпрос 2
Как се дефинират класове в Haskell? Дайте пример за дефиниция на клас.  

Отговор:  
Класовете се използват за дефиниране на набор от функции, които трябва да бъдат реализирани за различни типове данни. Това е аналогично на интерфейси или абстрактни класове в други програмни езици.  


Общият вид изглежда като:  

```hs
class Name type where
       <function1> :: <function1_signiture>
       <function2> :: <function2_signiture>
        ...
```

Дефинираме клас `Eq`, който описва типовете, чиито стойности могат да бъдат сравнявани за равенство.

```hs
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x /= y = not (x == y)
```


Ще дефинираме инстанция на класа `Eq` за типа `Int`:

```hs
instance Eq Int where
    x == y = x `primEqInt` y
```
<br>

### Въпрос 3
Обяснете понятието „алгебричен тип“ в езика Haskell. Дайте два примера за дефиниции на полиморфни алгебрични типове.  

Отговор:  
Алгебричните типове данни (algebraic data types - ADTs) в Haskell представляват един от основните начини за дефиниране на нови типове данни. Те могат да бъдат разделени на два основни вида: **продуктови типове** и `сумарни типове`.

- **Продуктови типове**: Представляват структури, които съдържат няколко полета, всяко от които може да е от различен тип. Това е аналогично на записи (records) или структури (structs) в други езици.

- `Сумарни типове`: Представляват структури, които могат да приемат различни форми (варианти), всяка от които може да има различна структура. Това е аналогично на *обединенията (unions)* в езици като C++

```hs
data Maybe a = Nothing | Just a
```

`Maybe` е *продуктов тип*, който може да съдържа или стойност от тип `a`, или никаква стойност.

```hs
data Sample a = Red a | Green a | Blue a
```

`Sample` е *сумарен тип*, който може да съдържа стойност от тип `a` или стойност от тип `b`.

<br>

### Въпрос 4
Дайте пример за частично прилагане на функция в Haskell. Обяснете какъв е типът на резултата от частичното прилагане във Вашия пример.  

Отговор:  
Частичното прилагане на функция означава да се прилагат някои от аргументите на функцията, но не всички, като резултатът е нова функция, която очаква останалите аргументи. Това е възможно, защото функциите в Haskell са кюриирани, което означава, че всяка функция с повече от един аргумент се разглежда като последователност от функции, всяка от които приема един аргумент и връща функция, която приема следващия аргумент.  

С прилагане на всеки следващ аргумент, получаваме нова функция, чийто тип е фунцкия, която приема следващите аргументи без текущия.  

Това е полезен инструмент, тъй като позволява създаването на по-малки и специфични функции от общи функции, което улеснява повторната употреба на код и подобрява четимостта.  


Разглеждаме следната функция:
```hs
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
```

Сега ще приложим частично тази функция, като зададем първия аргумент:
```hs
foo :: Int -> Int -> Int
foo = addThree 5
```

`foo` е резултатът от частичното прилагане на `addThree` с първи аргумент *5*.


Пример:
```hs
result = foo 3 4
```
Резултатът ще бъде *3 + 4 + 5 = 12* 

<br>

### Въпрос 5
Проследете стъпка по стъпка процеса на оценяване и напишете оценката на всеки от следващите изрази на езика Haskell:
- (\x y z -> x y z) (\x y -> x\*x+y\*y) 3 4
- sum (map (\f -> f 3) [\x->x, \x->x*x, \x->x*x*x])

Отговор:  
- `(\x y z -> x y z) (\x y -> x*x+y*y) 3 4`
Преди да се изпълни изразът, ще се изпълни ламбда изразът, подаден за първи аргумент, след това вторият за втората ламбда функция и накрая цялостният израз.
1. (\x y z -> x y z) - това е ламбда израз, който приема една фунцкия и 2 параметъра към нея
2. (\x y -> x*x+y*y) - това е функцията
3. 3 4 - 2-та параметъра на фунцкията

Резултатът е 25. 


sum (map (\f -> f 3) [\x->x, \x->x*x, \x->x*x*x])
Първо ще се изпълни функцията map фурху списъкът от функции. Той ще го трансформира в списък от числа. След това ще може да се изпълни sum

Резултатът е 3+9+27 = 39.
